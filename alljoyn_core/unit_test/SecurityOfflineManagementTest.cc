/******************************************************************************
 *    Copyright (c) Open Connectivity Foundation (OCF), AllJoyn Open Source
 *    Project (AJOSP) Contributors and others.
 *
 *    SPDX-License-Identifier: Apache-2.0
 *
 *    All rights reserved. This program and the accompanying materials are
 *    made available under the terms of the Apache License, Version 2.0
 *    which accompanies this distribution, and is available at
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Copyright (c) Open Connectivity Foundation and Contributors to AllSeen
 *    Alliance. All rights reserved.
 *
 *    Permission to use, copy, modify, and/or distribute this software for
 *    any purpose with or without fee is hereby granted, provided that the
 *    above copyright notice and this permission notice appear in all
 *    copies.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 *    WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 *    WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 *    AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 *    DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 *    PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 *    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 *    PERFORMANCE OF THIS SOFTWARE.
 ******************************************************************************/
#include <gtest/gtest.h>
#include <alljoyn/AllJoynStd.h>
#include <alljoyn/AuthListener.h>
#include <alljoyn/BusAttachment.h>
#include <alljoyn/SecurityApplicationProxy.h>
#include <qcc/Util.h>
#include <map>

#include "InMemoryKeyStore.h"
#include "XmlManifestConverter.h"
#include "KeyStore.h"
#include "ajTestCommon.h"
#include "SecurityTestHelper.h"

#define TEN_MINS 600 // 600 secs is 10 mins

using namespace ajn;
using namespace qcc;
using namespace std;

/* these keys were generated by the unit test common/unit_test/CertificateECCTest.GenSelfSignECCX509CertForBBservice */
static const char s_ecdsaPrivateKeyPEM[] = {
    "-----BEGIN EC PRIVATE KEY-----\n"
    "MDECAQEEII9MndKAfsYuLIsINFNkTmTMslzcYglHcVF/+l2dg2dxoAoGCCqGSM49\n"
    "AwEH\n"
    "-----END EC PRIVATE KEY-----"
};

/* Certificate expires 2026-02-24 00:24:24 UTC */
static const char s_ecdsaCertChainX509PEM[] = {
    "-----BEGIN CERTIFICATE-----\n"
    "MIIBtTCCAVugAwIBAgIHMTAxMDEwMTAKBggqhkjOPQQDAjBCMRUwEwYDVQQLDAxv\n"
    "cmdhbml6YXRpb24xKTAnBgNVBAMMIDI2MDM2YzFlMDM1ZjgzYTczNWQ1YTZmODVi\n"
    "YjhmYjE1MB4XDTE2MDIyNzAwMjQyNFoXDTI2MDIyNDAwMjQyNFowQjEVMBMGA1UE\n"
    "CwwMb3JnYW5pemF0aW9uMSkwJwYDVQQDDCBiNTMzMzExZDg2NDhkY2MwNTQ3NzM2\n"
    "ZDUwOTRiYjYyMDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEET2YJ7f0tvyyPj\n"
    "mx9WLA/0IWfKsp/PmpBH3h2VcJgKVinRDi5RTn5aBV6GkYCT2S/pMkwyqvv6ZbRP\n"
    "sYwM402jPDA6MAwGA1UdEwQFMAMBAf8wFQYDVR0lBA4wDAYKKwYBBAGC3nwBATAT\n"
    "BgNVHSMEDDAKoAhHNsLWWLZ/4zAKBggqhkjOPQQDAgNIADBFAiBjfRMGrHQ49Ys7\n"
    "tjgN8u+4AgraJ4ep5PbZTsdQUAqptQIhAKjAYghpuu95Wfg7GSNPShtZOm/FfB3I\n"
    "sr1PNKFcqHcL\n"
    "-----END CERTIFICATE-----"
};

class SecurityOfflineManagementTestSessionPortListener : public SessionPortListener {
  public:
    virtual bool AcceptSessionJoiner(SessionPort sessionPort, const char* joiner, const SessionOpts& opts) {
        QCC_UNUSED(sessionPort);
        QCC_UNUSED(joiner);
        QCC_UNUSED(opts);
        return true;
    }
};

class SecurityOfflineTestChirpSignalReceiver : public MessageReceiver {
  public:
    SecurityOfflineTestChirpSignalReceiver() : signalReceivedFlag(false) { }
    void ChirpSignalHandler(const InterfaceDescription::Member* member,
                            const char* sourcePath, Message& msg) {
        QCC_UNUSED(member);
        QCC_UNUSED(sourcePath);
        QCC_UNUSED(msg);
        signalReceivedFlag = true;
    }
    bool signalReceivedFlag;
};

class SecurityOfflineManagementTest : public testing::Test {
  public:
    SecurityOfflineManagementTest() :
        managerBus("SecurityOfflineManagementManager"),
        peer1Bus("SecurityOfflineManagementPeer1"),
        peer2Bus("SecurityOfflineManagementPeer2"),
        peer3Bus("SecurityOfflineManagementPeer3"),
        managerSessionPort(42),
        peer1SessionPort(42),
        peer2SessionPort(42),
        interfaceName("org.allseen.test.SecurityApplication.rules"),
        managerAuthListener(nullptr),
        peer1AuthListener(nullptr),
        peer2AuthListener(nullptr),
        peer3AuthListener(nullptr) {
    }

    virtual void SetUp() {
        ASSERT_EQ(ER_OK, managerBus.Start());
        ASSERT_EQ(ER_OK, peer1Bus.Start());
        ASSERT_EQ(ER_OK, peer2Bus.Start());
        ASSERT_EQ(ER_OK, peer3Bus.Start());

        // Register in memory keystore listeners
        ASSERT_EQ(ER_OK, managerBus.RegisterKeyStoreListener(managerKeyStoreListener));
        ASSERT_EQ(ER_OK, peer1Bus.RegisterKeyStoreListener(peer1KeyStoreListener));
        ASSERT_EQ(ER_OK, peer2Bus.RegisterKeyStoreListener(peer2KeyStoreListener));
        ASSERT_EQ(ER_OK, peer3Bus.RegisterKeyStoreListener(peer3KeyStoreListener));

        managerAuthListener = new DefaultECDHEAuthListener();
        peer1AuthListener = new DefaultECDHEAuthListener();
        peer2AuthListener = new DefaultECDHEAuthListener();
        peer3AuthListener = new DefaultECDHEAuthListener();

        ASSERT_EQ(ER_OK, managerBus.EnablePeerSecurity("ALLJOYN_ECDHE_ECDSA", managerAuthListener, nullptr, false));
        ASSERT_EQ(ER_OK, peer1Bus.EnablePeerSecurity("ALLJOYN_ECDHE_ECDSA", peer1AuthListener, nullptr, false));
        ASSERT_EQ(ER_OK, peer2Bus.EnablePeerSecurity("ALLJOYN_ECDHE_ECDSA", peer2AuthListener, nullptr, false));
        ASSERT_EQ(ER_OK, peer3Bus.EnablePeerSecurity("ALLJOYN_ECDHE_ECDSA", peer3AuthListener, nullptr, false));

        SecurityTestHelper::GetGUID(managerBus, managerGuid);
        SetManifestTemplate(managerBus);
        SetManifestTemplate(peer1Bus);
        SetManifestTemplate(peer2Bus);
        SetManifestTemplate(peer3Bus);

        // We are not marking the interface as a secure interface. Some of the
        // tests don't use security. So we use Object based security for any
        // test that security is required.
        interface = "<node>"
                    "<interface name='" + String(interfaceName) + "'>"
                    "  <method name='Echo'>"
                    "    <arg name='shout' type='s' direction='in'/>"
                    "    <arg name='reply' type='s' direction='out'/>"
                    "  </method>"
                    "  <signal name='Chirp'>"
                    "    <arg name='tweet' type='s'/>"
                    "  </signal>"
                    "  <property name='Prop1' type='i' access='readwrite'/>"
                    "  <property name='Prop2' type='i' access='readwrite'/>"
                    "</interface>"
                    "</node>";

        ASSERT_EQ(ER_OK, managerBus.CreateInterfacesFromXml(interface.c_str()));
        ASSERT_EQ(ER_OK, peer1Bus.CreateInterfacesFromXml(interface.c_str()));
        ASSERT_EQ(ER_OK, peer2Bus.CreateInterfacesFromXml(interface.c_str()));
        ASSERT_EQ(ER_OK, peer3Bus.CreateInterfacesFromXml(interface.c_str()));

        Manifest manifests[1];
        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

        // Get manager key
        KeyInfoNISTP256 managerKey;
        PermissionConfigurator& pcManager = managerBus.GetPermissionConfigurator();
        ASSERT_EQ(ER_OK, pcManager.GetSigningPublicKey(managerKey));

        //Create peer1 key
        KeyInfoNISTP256 peer1Key;
        PermissionConfigurator& pcPeer1 = peer1Bus.GetPermissionConfigurator();
        ASSERT_EQ(ER_OK, pcPeer1.GetSigningPublicKey(peer1Key));

        // Create peer2 key
        KeyInfoNISTP256 peer2Key;
        PermissionConfigurator& pcPeer2 = peer2Bus.GetPermissionConfigurator();
        ASSERT_EQ(ER_OK, pcPeer2.GetSigningPublicKey(peer2Key));

        PermissionConfigurator::ApplicationState applicationStateManager;
        ASSERT_EQ(ER_OK, pcManager.GetApplicationState(applicationStateManager));
        EXPECT_EQ(PermissionConfigurator::CLAIMABLE, applicationStateManager);

        PermissionConfigurator::ApplicationState applicationStatePeer1;
        ASSERT_EQ(ER_OK, pcPeer1.GetApplicationState(applicationStatePeer1));
        EXPECT_EQ(PermissionConfigurator::CLAIMABLE, applicationStatePeer1);

        PermissionConfigurator::ApplicationState applicationStatePeer2;
        ASSERT_EQ(ER_OK, pcPeer2.GetApplicationState(applicationStatePeer2));
        EXPECT_EQ(PermissionConfigurator::CLAIMABLE, applicationStatePeer2);

        // Create identityCert
        const size_t certChainSize = 1;
        IdentityCertificate identityCertChainMaster[certChainSize];

        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateIdentityCert(managerBus,
                                                                "0",
                                                                managerGuid.ToString(),
                                                                managerKey.GetPublicKey(),
                                                                "ManagerAlias",
                                                                identityCertChainMaster[0])) << "Failed to create identity certificate.";

        ASSERT_EQ(ER_OK, SecurityTestHelper::SignManifest(managerBus, identityCertChainMaster[0], manifests[0]));
        vector<std::string> manifestsXmlStrings;
        vector<AJ_PCSTR> manifestsXmls;
        ASSERT_EQ(ER_OK, XmlManifestConverter::ManifestsToXmlArray(manifests, ArraySize(manifests), manifestsXmlStrings));
        SecurityTestHelper::UnwrapStrings(manifestsXmlStrings, manifestsXmls);
        ASSERT_EQ(ER_OK, pcManager.Claim(managerKey,
                                         managerGuid,
                                         managerKey,
                                         identityCertChainMaster, certChainSize,
                                         manifestsXmls.data(), manifestsXmls.size()));

        ECCPublicKey managerPublicKey;
        SecurityTestHelper::GetAppPublicKey(managerBus, managerPublicKey);
        ASSERT_EQ(*managerKey.GetPublicKey(), managerPublicKey);

        //Create peer1 identityCert
        IdentityCertificate identityCertChainPeer1[certChainSize];

        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateIdentityCert(managerBus,
                                                                "0",
                                                                managerGuid.ToString(),
                                                                peer1Key.GetPublicKey(),
                                                                "Peer1Alias",
                                                                identityCertChainPeer1[0])) << "Failed to create identity certificate.";

        ASSERT_EQ(ER_OK, SecurityTestHelper::SignManifest(managerBus, identityCertChainPeer1[0], manifests[0]));
        //Manager claims Peers
        ASSERT_EQ(ER_OK, XmlManifestConverter::ManifestsToXmlArray(manifests, ArraySize(manifests), manifestsXmlStrings));
        SecurityTestHelper::UnwrapStrings(manifestsXmlStrings, manifestsXmls);
        ASSERT_EQ(ER_OK, pcPeer1.Claim(managerKey,
                                       managerGuid,
                                       managerKey,
                                       identityCertChainPeer1, certChainSize,
                                       manifestsXmls.data(), manifestsXmls.size()));

        // Create peer2 identityCert
        IdentityCertificate identityCertChainPeer2[certChainSize];
        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateIdentityCert(managerBus,
                                                                "0",
                                                                managerGuid.ToString(),
                                                                peer2Key.GetPublicKey(),
                                                                "Peer2Alias",
                                                                identityCertChainPeer2[0])) << "Failed to create identity certificate.";
        ASSERT_EQ(ER_OK, SecurityTestHelper::SignManifest(managerBus, identityCertChainPeer2[0], manifests[0]));
        ASSERT_EQ(ER_OK, XmlManifestConverter::ManifestsToXmlArray(manifests, ArraySize(manifests), manifestsXmlStrings));
        SecurityTestHelper::UnwrapStrings(manifestsXmlStrings, manifestsXmls);
        ASSERT_EQ(ER_OK, pcPeer2.Claim(managerKey,
                                       managerGuid,
                                       managerKey,
                                       identityCertChainPeer2, certChainSize,
                                       manifestsXmls.data(), manifestsXmls.size()));

        ASSERT_EQ(ER_OK, pcManager.GetApplicationState(applicationStateManager));
        EXPECT_EQ(PermissionConfigurator::CLAIMED, applicationStateManager);

        ASSERT_EQ(ER_OK, pcPeer1.GetApplicationState(applicationStatePeer1));
        EXPECT_EQ(PermissionConfigurator::CLAIMED, applicationStatePeer1);

        ASSERT_EQ(ER_OK, pcPeer2.GetApplicationState(applicationStatePeer2));
        EXPECT_EQ(PermissionConfigurator::CLAIMED, applicationStatePeer2);
    }

    virtual void TearDown() {
        managerBus.Stop();
        managerBus.Join();

        peer1Bus.Stop();
        peer1Bus.Join();

        peer2Bus.Stop();
        peer2Bus.Join();

        peer3Bus.Stop();
        peer3Bus.Join();

        delete managerAuthListener;
        delete peer1AuthListener;
        delete peer2AuthListener;
        delete peer3AuthListener;
    }

    void InstallMembershipOnManager()
    {
        // Get manager key
        KeyInfoNISTP256 managerKey;
        PermissionConfigurator& pcManager = managerBus.GetPermissionConfigurator();
        ASSERT_EQ(ER_OK, pcManager.GetSigningPublicKey(managerKey));

        String membershipSerial = "1";
        qcc::MembershipCertificate managerMembershipCertificate[1];
        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert(membershipSerial,
                                                                  managerBus,
                                                                  "managerBus",
                                                                  managerKey.GetPublicKey(),
                                                                  managerGuid,
                                                                  managerMembershipCertificate[0],
                                                                  true
                                                                  ));
        ASSERT_EQ(ER_OK, pcManager.InstallMembership(managerMembershipCertificate, 1));
    }

    void InstallMembershipOnPeer1()
    {
        //Create peer1 key
        KeyInfoNISTP256 peer1Key;
        PermissionConfigurator& pcPeer1 = peer1Bus.GetPermissionConfigurator();
        ASSERT_EQ(ER_OK, pcPeer1.GetSigningPublicKey(peer1Key));

        String membershipSerial = "1";
        qcc::MembershipCertificate peer1MembershipCertificate[1];
        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert(membershipSerial,
                                                                  managerBus,
                                                                  "peer1Bus",
                                                                  peer1Key.GetPublicKey(),
                                                                  managerGuid,
                                                                  peer1MembershipCertificate[0]
                                                                  ));
        ASSERT_EQ(ER_OK, pcPeer1.InstallMembership(peer1MembershipCertificate, 1));
    }

    void InstallMembershipOnPeer2()
    {
        // Create peer2 key
        KeyInfoNISTP256 peer2Key;
        PermissionConfigurator& pcPeer2 = peer2Bus.GetPermissionConfigurator();
        ASSERT_EQ(ER_OK, pcPeer2.GetSigningPublicKey(peer2Key));

        String membershipSerial = "1";
        qcc::MembershipCertificate peer2MembershipCertificate[1];
        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert(membershipSerial,
                                                                  managerBus,
                                                                  "peer2Bus",
                                                                  peer2Key.GetPublicKey(),
                                                                  managerGuid,
                                                                  peer2MembershipCertificate[0]
                                                                  ));
        ASSERT_EQ(ER_OK, pcPeer2.InstallMembership(peer2MembershipCertificate, 1));
    }

    void SetManifestTemplate(BusAttachment& bus)
    {
        Manifest manifestTemplate;
        ASSERT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifestTemplate));
        ASSERT_EQ(ER_OK, bus.GetPermissionConfigurator().SetPermissionManifestTemplate(const_cast<PermissionPolicy::Rule*>(manifestTemplate->GetRules().data()), manifestTemplate->GetRules().size()));
    }

    QStatus ConnectBuses()
    {
        QStatus status = managerBus.Connect();
        if (ER_OK != status) {
            return status;
        }

        status = peer1Bus.Connect();
        if (ER_OK != status) {
            return status;
        }

        status = peer2Bus.Connect();
        if (ER_OK != status) {
            return status;
        }

        SessionOpts opts1;
        status = managerBus.BindSessionPort(managerSessionPort, opts1, managerSessionPortListener);
        if (ER_OK != status) {
            return status;
        }

        SessionOpts opts2;
        status = peer1Bus.BindSessionPort(peer1SessionPort, opts2, peer1SessionPortListener);
        if (ER_OK != status) {
            return status;
        }

        SessionOpts opts3;
        status = peer2Bus.BindSessionPort(peer2SessionPort, opts3, peer2SessionPortListener);
        if (ER_OK != status) {
            return status;
        }

        return status;
    }

    BusAttachment managerBus;
    BusAttachment peer1Bus;
    BusAttachment peer2Bus;
    BusAttachment peer3Bus;

    SessionPort managerSessionPort;
    SessionPort peer1SessionPort;
    SessionPort peer2SessionPort;

    SecurityOfflineManagementTestSessionPortListener managerSessionPortListener;
    SecurityOfflineManagementTestSessionPortListener peer1SessionPortListener;
    SecurityOfflineManagementTestSessionPortListener peer2SessionPortListener;

    InMemoryKeyStoreListener managerKeyStoreListener;
    InMemoryKeyStoreListener peer1KeyStoreListener;
    InMemoryKeyStoreListener peer2KeyStoreListener;
    InMemoryKeyStoreListener peer3KeyStoreListener;

    String interface;
    const char* interfaceName;
    DefaultECDHEAuthListener* managerAuthListener;
    DefaultECDHEAuthListener* peer1AuthListener;
    DefaultECDHEAuthListener* peer2AuthListener;
    DefaultECDHEAuthListener* peer3AuthListener;

    //Random GUID used for the SecurityManager
    GUID128 managerGuid;
};

/*
 * Purpose:
 * Latest Policy to be installed should have a serial number greater than the
 * previous policy's serial number. Else, the previous policy should not be deleted.
 *
 * SetUp:
 * manager claims the peer1
 * manager creates a policy  (policy 1):
 * Serial number: 1234
 * ACL: ANY_TRUSTED
 * Rule1: Object Path=*, Interface=*, Member Name=*, Type=Method, Action mask:  PROVIDE
 *
 * manager calls UpdatePolicy on peer1.
 * manager calls GetProperty ("policy") on the peer1
 *
 * manager creates another policy  (policy 2):
 * Serial number: 1200
 * ACL: ALL
 * Rule1: Object Path=/abc, Interface=*, Member Name=*, Type=Method, Action mask:  PROVIDE
 * manager calls UpdatePolicy on peer1
 * manager calls GetProperty ("policy") on peer1.
 *
 * Verify:
 * UpdatePolicy (policy1) should succeed.
 * GetProperty ("Policy") should fetch policy 1.
 * Update policy ("Policy2") should fail with ER_POLICY_NOT_NEWER.
 * GetProperty("Policy") should still fetch policy1.
 */
TEST_F(SecurityOfflineManagementTest, UpdatePolicy_fails_if_version_not_newer)
{
    InstallMembershipOnManager();
    InstallMembershipOnPeer1();

    /*
     * creates a policy  (policy 1):
     * Serial number: 1234
     * ACL: ANY_TRUSTED
     * Rule1: Object Path=*, Interface=*, Member Name=*, Type=Method, Action mask:  PROVIDE
     */
    PermissionPolicy policy1;
    policy1.SetSerialNumber(1234);
    {
        PermissionPolicy::Acl acls[1];
        {
            PermissionPolicy::Peer peers[1];
            peers[0].SetType(PermissionPolicy::Peer::PEER_ANY_TRUSTED);
            acls[0].SetPeers(1, peers);
        }
        {
            PermissionPolicy::Rule rules[1];
            rules[0].SetObjPath("*");
            rules[0].SetInterfaceName("*");
            {
                PermissionPolicy::Rule::Member members[1];
                members[0].Set("*",
                               PermissionPolicy::Rule::Member::METHOD_CALL,
                               PermissionPolicy::Rule::Member::ACTION_PROVIDE);
                rules[0].SetMembers(1, members);
            }
            acls[0].SetRules(1, rules);
        }
        policy1.SetAcls(1, acls);
    }

    PermissionConfigurator& pcPeer1 = peer1Bus.GetPermissionConfigurator();

    {
        PermissionPolicy peer1DefaultPolicy;
        ASSERT_EQ(ER_OK, pcPeer1.GetDefaultPolicy(peer1DefaultPolicy));
        SecurityTestHelper::UpdatePolicyWithValuesFromDefaultPolicy(peer1DefaultPolicy, policy1, true, true);
    }

    ASSERT_EQ(ER_OK, pcPeer1.UpdatePolicy(policy1));

    PermissionPolicy fetchedPolicy;
    ASSERT_EQ(ER_OK, pcPeer1.GetPolicy(fetchedPolicy));
    EXPECT_EQ(static_cast<uint32_t>(1234), fetchedPolicy.GetSerialNumber());
    EXPECT_EQ(policy1.GetSerialNumber(), fetchedPolicy.GetSerialNumber());
    EXPECT_EQ(policy1, fetchedPolicy);
}

/*
 * Purpose:
 * New policy installed should override the older policy.
 *
 * SetUp:
 * manager claims the peer1
 *
 * manager creates a policy  (policy 1):
 * Serial number: 1234
 * ACL: ANY_TRUSTED
 * Rule1: Object Path=*, Interface=*, Member Name=*, Type=Method, Action mask:  PROVIDE
 *
 * manager calls UpdatePolicy on peer1
 * manager calls GetProperty ("policy") on peer1
 *
 * manager creates another policy  (policy 2):
 * Serial number: 1235
 * ACL: ALL
 * Rule1: Object Path=/abc, Interface=*, Member Name=*, Type=Method, Action mask:  PROVIDE
 *
 * manager calls UpdatePolicy on peer1
 * manager calls GetProperty ("policy") on peer1
 *
 * Verify:
 * UpdatePolicy (policy1) should succeed.
 * GetProperty ("Policy") should fetch policy 1.
 * Update policy ("Policy2") should succeed.
 * GetProperty("Policy") should still fetch policy2.
 */
TEST_F(SecurityOfflineManagementTest, UpdatePolicy_new_policy_should_override_older_policy)
{

    InstallMembershipOnManager();
    InstallMembershipOnPeer1();

    /*
     * manager creates a policy  (policy 1):
     * Serial number: 1234
     * ACL: ANY_TRUSTED
     * Rule1: Object Path=*, Interface=*, Member Name=*, Type=Method, Action mask:  PROVIDE
     */
    PermissionPolicy policy1;
    policy1.SetSerialNumber(1234);
    {
        PermissionPolicy::Acl acls[1];
        {
            PermissionPolicy::Peer peers[1];
            peers[0].SetType(PermissionPolicy::Peer::PEER_ANY_TRUSTED);
            acls[0].SetPeers(1, peers);
        }
        {
            PermissionPolicy::Rule rules[1];
            rules[0].SetObjPath("*");
            rules[0].SetInterfaceName("*");
            {
                PermissionPolicy::Rule::Member members[1];
                members[0].Set("*",
                               PermissionPolicy::Rule::Member::METHOD_CALL,
                               PermissionPolicy::Rule::Member::ACTION_PROVIDE);
                rules[0].SetMembers(1, members);
            }
            acls[0].SetRules(1, rules);
        }
        policy1.SetAcls(1, acls);
    }

    PermissionConfigurator& pcPeer1 = peer1Bus.GetPermissionConfigurator();

    {
        PermissionPolicy peer1DefaultPolicy;
        ASSERT_EQ(ER_OK, pcPeer1.GetDefaultPolicy(peer1DefaultPolicy));
        SecurityTestHelper::UpdatePolicyWithValuesFromDefaultPolicy(peer1DefaultPolicy, policy1, true, true);
    }

    ASSERT_EQ(ER_OK, pcPeer1.UpdatePolicy(policy1));

    PermissionPolicy fetchedPolicy;
    ASSERT_EQ(ER_OK, pcPeer1.GetPolicy(fetchedPolicy));

    EXPECT_EQ(policy1.GetSerialNumber(), fetchedPolicy.GetSerialNumber());
    EXPECT_EQ(policy1, fetchedPolicy);

    /*
     * manager creates another policy  (policy 2):
     * Serial number: 1235
     * ACL: ALL
     * Rule1: Object Path=/abc, Interface=*, Member Name=*, Type=Method, Action mask:  PROVIDE
     */
    PermissionPolicy policy2;
    policy2.SetSerialNumber(1235);
    {
        PermissionPolicy::Acl acls[1];
        {
            PermissionPolicy::Peer peers[1];
            peers[0].SetType(PermissionPolicy::Peer::PEER_ALL);
            acls[0].SetPeers(1, peers);
        }
        {
            PermissionPolicy::Rule rules[1];
            rules[0].SetObjPath("/abc");
            rules[0].SetInterfaceName("*");
            {
                PermissionPolicy::Rule::Member members[1];
                members[0].Set("*",
                               PermissionPolicy::Rule::Member::METHOD_CALL,
                               PermissionPolicy::Rule::Member::ACTION_PROVIDE);
                rules[0].SetMembers(1, members);
            }
            acls[0].SetRules(1, rules);
        }
        policy2.SetAcls(1, acls);
    }

    {
        PermissionPolicy peer1DefaultPolicy;
        ASSERT_EQ(ER_OK, pcPeer1.GetDefaultPolicy(peer1DefaultPolicy));
        SecurityTestHelper::UpdatePolicyWithValuesFromDefaultPolicy(peer1DefaultPolicy, policy2, true, true);
    }

    ASSERT_EQ(ER_OK, pcPeer1.UpdatePolicy(policy2));

    PermissionPolicy fetchedPolicy2;

    ASSERT_EQ(ER_OK, pcPeer1.GetPolicy(fetchedPolicy2));
    EXPECT_NE(policy1, fetchedPolicy2);
    EXPECT_EQ(policy2.GetSerialNumber(), fetchedPolicy2.GetSerialNumber());
    EXPECT_EQ(policy2, fetchedPolicy2);
}

class SecurityManagementPolicy2AuthListener : public AuthListener {

  public:
    SecurityManagementPolicy2AuthListener() : authenticationSuccessfull(false) {
    }

    QStatus RequestCredentialsAsync(const char* authMechanism, const char* authPeer, uint16_t authCount, const char* userId, uint16_t credMask, void* context)
    {
        QCC_UNUSED(userId);
        QCC_UNUSED(authCount);
        QCC_UNUSED(authPeer);
        Credentials creds;
        if (strcmp(authMechanism, "ALLJOYN_ECDHE_ECDSA") == 0) {
            if ((credMask& AuthListener::CRED_PRIVATE_KEY) == AuthListener::CRED_PRIVATE_KEY) {
                String pk(s_ecdsaPrivateKeyPEM, strlen(s_ecdsaPrivateKeyPEM));
                creds.SetPrivateKey(pk);
                //printf("AuthListener::RequestCredentials for key exchange %s sends DSA private key %s\n", authMechanism, pk.c_str());
            }
            if ((credMask& AuthListener::CRED_CERT_CHAIN) == AuthListener::CRED_CERT_CHAIN) {
                String cert(s_ecdsaCertChainX509PEM, strlen(s_ecdsaCertChainX509PEM));
                creds.SetCertChain(cert);
                //printf("AuthListener::RequestCredentials for key exchange %s sends DSA public cert %s\n", authMechanism, cert.c_str());
            }
            return RequestCredentialsResponse(context, true, creds);
        }
        return RequestCredentialsResponse(context, false, creds);
    }
    QStatus VerifyCredentialsAsync(const char* authMechanism, const char* authPeer, const Credentials& creds, void* context) {
        QCC_UNUSED(authPeer);
        if (strcmp(authMechanism, "ALLJOYN_ECDHE_ECDSA") == 0) {
            if (creds.IsSet(AuthListener::CRED_CERT_CHAIN)) {
                //printf("Verify\n%s\n", creds.GetCertChain().c_str());
                return VerifyCredentialsResponse(context, true);
            }
        }
        return VerifyCredentialsResponse(context, false);
    }

    void AuthenticationComplete(const char* authMechanism, const char* authPeer, bool success) {
        QCC_UNUSED(authMechanism);
        QCC_UNUSED(authPeer);
        QCC_UNUSED(success);
        if (success) {
            authenticationSuccessfull = true;
        }
    }

    void SecurityViolation(QStatus status, const Message& msg) {
        QCC_UNUSED(status);
        QCC_UNUSED(msg);
    }
    bool authenticationSuccessfull;

};

TEST_F(SecurityOfflineManagementTest, Update_identity_fails_on_invalid_icc_chain)
{
    PermissionConfigurator& pcPeer1 = peer1Bus.GetPermissionConfigurator();
    PermissionConfigurator& pcPeer2 = peer2Bus.GetPermissionConfigurator();

    Manifest manifests[1];
    EXPECT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

    uint8_t managerCN[] = { 1, 2, 3, 4 };
    uint8_t intermediateCN[] = { 5, 6, 7, 8 };
    uint8_t leafCN[] = { 9, 0, 1, 2 };

    //Create the CA cert
    qcc::IdentityCertificate caCert;
    caCert.SetSerial((uint8_t*)"5678", 5);
    caCert.SetIssuerCN(managerCN, 4);
    caCert.SetSubjectCN(managerCN, 4);
    CertificateX509::ValidPeriod validityCA;
    validityCA.validFrom = 1427404154;
    validityCA.validTo = 1427404154 + 630720000;
    caCert.SetValidity(&validityCA);

    KeyInfoNISTP256 managerPublicKey;
    PermissionConfigurator& permissionConfigurator = managerBus.GetPermissionConfigurator();
    EXPECT_EQ(ER_OK, permissionConfigurator.GetSigningPublicKey(managerPublicKey));

    caCert.SetSubjectPublicKey(managerPublicKey.GetPublicKey());
    caCert.SetAlias("ca-cert-alias");
    caCert.SetCA(true);

    //sign the ca cert
    EXPECT_EQ(ER_OK, permissionConfigurator.SignCertificate(caCert));

    // Create the intermediate certificate using peer1
    qcc::IdentityCertificate peer1Cert;
    peer1Cert.SetSerial((uint8_t*)"1234", 5);
    peer1Cert.SetIssuerCN(managerCN, 4);
    peer1Cert.SetSubjectCN(intermediateCN, 4);
    CertificateX509::ValidPeriod validity;
    validity.validFrom = qcc::GetEpochTimestamp() / 1000;
    validity.validTo = validity.validFrom + TEN_MINS;
    peer1Cert.SetValidity(&validity);

    ECCPublicKey peer1PublicKey;
    SecurityTestHelper::GetAppPublicKey(peer1Bus, peer1PublicKey);

    peer1Cert.SetSubjectPublicKey(&peer1PublicKey);
    peer1Cert.SetAlias("intermediate-cert-alias");
    peer1Cert.SetCA(true);

    //We intentionally skip signing the leaf cert
    PermissionConfigurator& peer3PermissionConfigurator = peer3Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer3PermissionConfigurator.SignCertificate(peer1Cert));

    // Create the leaf certificate using peer2
    qcc::IdentityCertificate peer2Cert;
    peer2Cert.SetSerial((uint8_t*)"1234", 5);
    peer2Cert.SetIssuerCN(intermediateCN, 4);
    peer2Cert.SetSubjectCN(leafCN, 4);
    peer2Cert.SetValidity(&validity);

    ECCPublicKey peer2PublicKey;
    SecurityTestHelper::GetAppPublicKey(peer2Bus, peer2PublicKey);

    peer2Cert.SetSubjectPublicKey(&peer2PublicKey);
    peer2Cert.SetAlias("peer2-cert-alias");
    peer2Cert.SetCA(true);

    //sign the leaf cert
    ASSERT_EQ(ER_OK, pcPeer1.SignCertificate(peer2Cert));

    //We need identityCert chain CA1->Peer2
    const size_t certChainSize = 3;
    IdentityCertificate identityCertChain[certChainSize];
    identityCertChain[0] = peer2Cert;
    identityCertChain[1] = peer1Cert;
    identityCertChain[2] = caCert;

    ASSERT_EQ(ER_OK, SecurityTestHelper::SignManifest(peer1Bus, identityCertChain[0], manifests[0]));
    vector<std::string> manifestsXmlStrings;
    vector<AJ_PCSTR> manifestsXmls;
    ASSERT_EQ(ER_OK, XmlManifestConverter::ManifestsToXmlArray(manifests, ArraySize(manifests), manifestsXmlStrings));
    SecurityTestHelper::UnwrapStrings(manifestsXmlStrings, manifestsXmls);
    // Call UpdateIdentity to install the cert chain
    EXPECT_EQ(ER_INVALID_CERTIFICATE, pcPeer2.UpdateIdentity(identityCertChain, certChainSize, manifestsXmls.data(), manifestsXmls.size()))
        << "Failed to update Identity cert or manifest ";
}

TEST_F(SecurityOfflineManagementTest, install_membership_succeeds)
{
    Manifest manifests[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

    KeyInfoNISTP256 peer2PublicKey;
    PermissionConfigurator& peer2PermissionConfigurator = peer2Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.GetSigningPublicKey(peer2PublicKey));

    qcc::MembershipCertificate membershipCertificate[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("123",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));

    // Call InstallMembership
    EXPECT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";
}

TEST_F(SecurityOfflineManagementTest, install_membership_twice_succeeds)
{
    Manifest manifests[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

    KeyInfoNISTP256 peer2PublicKey;
    PermissionConfigurator& peer2PermissionConfigurator = peer2Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.GetSigningPublicKey(peer2PublicKey));

    qcc::MembershipCertificate membershipCertificate[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("123",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));

    // Call InstallMembership
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";

    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("456",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));


    // Call InstallMembership
    EXPECT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";
}

TEST_F(SecurityOfflineManagementTest, install_membership_fails_with_same_cert_serial)
{
    Manifest manifests[1];
    EXPECT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

    KeyInfoNISTP256 peer2PublicKey;
    PermissionConfigurator& peer2PermissionConfigurator = peer2Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.GetSigningPublicKey(peer2PublicKey));

    qcc::MembershipCertificate membershipCertificate[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("1",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));


    // Call InstallMembership
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";


    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("1",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));

    // Call InstallMembership
    EXPECT_EQ(ER_DUPLICATE_CERTIFICATE, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "InstallMembership succeeded when it should have failed";
}

TEST_F(SecurityOfflineManagementTest, remove_membership_fails_if_serial_does_not_match)
{
    Manifest manifests[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

    KeyInfoNISTP256 peer2PublicKey;
    PermissionConfigurator& peer2PermissionConfigurator = peer2Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.GetSigningPublicKey(peer2PublicKey));

    qcc::MembershipCertificate membershipCertificate[1];
    /* GetUniqueName returns an empty string when the bus is not connected, so we can't use that here. */
    EXPECT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("123",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));

    // Call InstallMembership
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";

    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("456",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));


    // Call InstallMembership
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";

    // Call GetProperty("MembershipSummaries"). This call should show 2 membership certificates
    MsgArg arg;
    std::vector<String> serials;
    std::vector<KeyInfoNISTP256> keyInfos;
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.GetMembershipSummaries(serials, keyInfos)) << "GetMembershipSummaries failed.";

    EXPECT_EQ(2U, serials.size());
    EXPECT_EQ(2U, keyInfos.size());

    String serial0("123");
    String serial1("456");
    // Compare the serial  in the certificates just retrieved
    // Membership certs are stored as a non-deterministic set so the order can
    // change. We just want to make sure both certificates are returned. The
    // only time order will remain the same is if the certificates are in a
    // certificate chain.
    if (serials[0] == serial0) {
        EXPECT_STREQ(serials[0].c_str(), serial0.c_str());
        EXPECT_STREQ(serials[1].c_str(), serial1.c_str());
    } else {
        EXPECT_STREQ(serials[0].c_str(), serial1.c_str());
        EXPECT_STREQ(serials[1].c_str(), serial0.c_str());
    }

    // Call RemoveMembership
    String fakeSerial("333");
    EXPECT_EQ(ER_CERTIFICATE_NOT_FOUND, peer2PermissionConfigurator.RemoveMembership(fakeSerial, keyInfos[0]));
}

TEST_F(SecurityOfflineManagementTest, remove_membership_fails_if_issuer_does_not_match)
{
    Manifest manifests[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

    KeyInfoNISTP256 peer2PublicKey;
    PermissionConfigurator& peer2PermissionConfigurator = peer2Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.GetSigningPublicKey(peer2PublicKey));

    qcc::MembershipCertificate membershipCertificate[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("123",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));

    // Call InstallMembership
    EXPECT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";

    EXPECT_EQ(ER_OK, SecurityTestHelper::CreateMembershipCert("456",
                                                              managerBus,
                                                              "peer2Bus",
                                                              peer2PublicKey.GetPublicKey(),
                                                              managerGuid,
                                                              membershipCertificate[0],
                                                              true
                                                              ));


    // Call InstallMembership
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.InstallMembership(membershipCertificate, 1)) << "Failed to install membership ";

    // Call GetProperty("MembershipSummaries"). This call should show 2 membership certificates
    MsgArg arg;
    std::vector<String> serials;
    std::vector<KeyInfoNISTP256> keyInfos;
    ASSERT_EQ(ER_OK, peer2PermissionConfigurator.GetMembershipSummaries(serials, keyInfos)) << "GetMembershipSummaries failed.";

    EXPECT_EQ((uint32_t)2, serials.size());
    EXPECT_EQ((uint32_t)2, keyInfos.size());

    String serial0("123");
    String serial1("456");
    // Compare the serial  in the certificates just retrieved
    // Membership certs are stored as a non-deterministic set so the order can
    // change. We just want to make sure both certificates are returned. The
    // only time order will remain the same is if the certificates are in a
    // certificate chain.
    if (serials[0] == serial0) {
        EXPECT_STREQ(serials[0].c_str(), serial0.c_str());
        EXPECT_STREQ(serials[1].c_str(), serial1.c_str());
    } else {
        EXPECT_STREQ(serials[0].c_str(), serial1.c_str());
        EXPECT_STREQ(serials[1].c_str(), serial0.c_str());
    }

    // Call RemoveMembership
    EXPECT_EQ(ER_CERTIFICATE_NOT_FOUND, peer2PermissionConfigurator.RemoveMembership(serials[0], peer2PublicKey));
}

TEST_F(SecurityOfflineManagementTest, successful_method_call_after_chained_membership_installation)
{
    BusAttachment busUsedAsCA("caBus");
    ASSERT_EQ(ER_OK, DeleteDefaultKeyStoreFile("caBus"));
    ASSERT_EQ(ER_OK, busUsedAsCA.Start());

    DefaultECDHEAuthListener* caAuthListener;
    caAuthListener = new DefaultECDHEAuthListener();

    ASSERT_EQ(ER_OK, busUsedAsCA.EnablePeerSecurity("ALLJOYN_ECDHE_NULL ALLJOYN_ECDHE_ECDSA", caAuthListener));

    qcc::GUID128 guildAuthorityGUID;
    GUID128 leafGuid;
    GUID128 interGuid;
    GUID128 caGUID;

    SecurityTestHelper::GetGUID(peer1Bus, leafGuid);
    SecurityTestHelper::GetGUID(peer3Bus, interGuid);
    SecurityTestHelper::GetGUID(busUsedAsCA, caGUID);

    Manifest manifests[1];
    ASSERT_EQ(ER_OK, SecurityTestHelper::CreateAllInclusiveManifest(manifests[0]));

    uint8_t managerCN[] = { 1, 2, 3, 4 };
    uint8_t intermediateCN[] = { 9, 9, 9, 9 };
    uint8_t caCN[] = { 9, 9, 9, 9 };
    uint8_t leafCN[] = { 9, 0, 1, 2 };

    //Create the CA cert
    qcc::IdentityCertificate caCert;
    caCert.SetSerial((uint8_t*)"1234", 5);
    caCert.SetIssuerCN(caCN, 4);
    caCert.SetSubjectCN(caCN, 4);
    CertificateX509::ValidPeriod validityCA;
    validityCA.validFrom = qcc::GetEpochTimestamp() / 1000;
    validityCA.validTo = validityCA.validFrom + TEN_MINS;
    caCert.SetValidity(&validityCA);

    KeyInfoNISTP256 caKey;
    PermissionConfigurator& caPC = busUsedAsCA.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, caPC.GetSigningPublicKey(caKey));

    caCert.SetSubjectPublicKey(caKey.GetPublicKey());
    caCert.SetAlias("ca-cert-alias");
    caCert.SetCA(true);

    //sign the ca cert
    ASSERT_EQ(ER_OK, caPC.SignCertificate(caCert));

    // Create the intermediate certificate using peer1
    qcc::IdentityCertificate peer1Cert;
    peer1Cert.SetSerial((uint8_t*)"2345", 5);
    peer1Cert.SetIssuerCN(caCN, 4);
    peer1Cert.SetSubjectCN(leafCN, 4);
    CertificateX509::ValidPeriod validity;
    validity.validFrom = qcc::GetEpochTimestamp() / 1000;
    validity.validTo = validity.validFrom + TEN_MINS;
    peer1Cert.SetValidity(&validity);

    ECCPublicKey peer1PublicKey;
    SecurityTestHelper::GetAppPublicKey(peer1Bus, peer1PublicKey);

    peer1Cert.SetSubjectPublicKey(&peer1PublicKey);
    peer1Cert.SetAlias("intermediate-cert-alias");
    peer1Cert.SetCA(false);

    //sign the leaf cert
    ASSERT_EQ(ER_OK, caPC.SignCertificate(peer1Cert));

    //We need identityCert chain CA1->Peer1
    const size_t certChainSize = 2;
    IdentityCertificate identityCertChain[certChainSize];
    identityCertChain[0] = peer1Cert;
    identityCertChain[1] = caCert;

    //
    // Create membership chain to be installed on peer 1
    //

    SecurityTestHelper::GetGUID(managerBus, guildAuthorityGUID);
    KeyInfoNISTP256 sgaKey;
    PermissionConfigurator& managerPC = managerBus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, managerPC.GetSigningPublicKey(sgaKey));

    // SGA membership certificate
    qcc::MembershipCertificate sgaMembershipCert;
    sgaMembershipCert.SetSerial((uint8_t*)"1234", 5);
    sgaMembershipCert.SetIssuerCN(managerCN, 4);
    sgaMembershipCert.SetSubjectCN(managerCN, 4);
    sgaMembershipCert.SetSubjectPublicKey(sgaKey.GetPublicKey());
    sgaMembershipCert.SetGuild(managerGuid);
    sgaMembershipCert.SetCA(true);
    validity.validFrom = qcc::GetEpochTimestamp() / 1000;
    validity.validTo = validity.validFrom + TEN_MINS;
    sgaMembershipCert.SetValidity(&validity);

    ASSERT_EQ(ER_OK, managerPC.SignCertificate(sgaMembershipCert));

    MembershipCertificate managerMembershipCertChain[1];
    managerMembershipCertChain[0] = sgaMembershipCert;

    ASSERT_EQ(ER_OK, managerPC.InstallMembership(managerMembershipCertChain, 1));

    // Intermediate membership certificate
    qcc::MembershipCertificate intermediateMembershipCert;
    intermediateMembershipCert.SetSerial((uint8_t*)"2345", 5);
    intermediateMembershipCert.SetIssuerCN(managerCN, 4);
    intermediateMembershipCert.SetSubjectCN(intermediateCN, 4);
    KeyInfoNISTP256 interKey;
    PermissionConfigurator& peer3PC = peer3Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer3PC.GetSigningPublicKey(interKey));
    intermediateMembershipCert.SetSubjectPublicKey(interKey.GetPublicKey());
    intermediateMembershipCert.SetGuild(interGuid);
    intermediateMembershipCert.SetCA(true);
    validity.validFrom = qcc::GetEpochTimestamp() / 1000;
    validity.validTo = validity.validFrom + TEN_MINS;
    intermediateMembershipCert.SetValidity(&validity);
    /* use the signing bus to sign the cert */
    ASSERT_EQ(ER_OK, managerPC.SignCertificate(intermediateMembershipCert));

    // Leaf membership certificate
    qcc::MembershipCertificate leafMembershipCert;
    leafMembershipCert.SetSerial((uint8_t*)"3456", 5);
    leafMembershipCert.SetIssuerCN(intermediateCN, 4);
    leafMembershipCert.SetSubjectCN(leafCN, 4);
    KeyInfoNISTP256 leafKey;
    PermissionConfigurator& peer1PC = peer1Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer1PC.GetSigningPublicKey(leafKey));
    leafMembershipCert.SetSubjectPublicKey(leafKey.GetPublicKey());
    leafMembershipCert.SetGuild(leafGuid);
    leafMembershipCert.SetCA(false);
    validity.validFrom = qcc::GetEpochTimestamp() / 1000;
    validity.validTo = validity.validFrom + TEN_MINS;
    leafMembershipCert.SetValidity(&validity);
    /* use the signing bus to sign the cert */
    ASSERT_EQ(ER_OK, peer3PC.SignCertificate(leafMembershipCert));

    const size_t membershipChainSize = 3;
    MembershipCertificate membershipCertChain[membershipChainSize];
    membershipCertChain[0] = leafMembershipCert;
    membershipCertChain[1] = intermediateMembershipCert;
    membershipCertChain[2] = sgaMembershipCert;

    //ASSERT_EQ(ER_OK, pcPeer1.Reset());
    ASSERT_EQ(ER_OK, peer1PC.InstallMembership(membershipCertChain, 3));

    EXPECT_EQ(ER_OK, SecurityTestHelper::SignManifest(busUsedAsCA, identityCertChain[0], manifests[0]));
    vector<std::string> manifestsXmlStrings;
    vector<AJ_PCSTR> manifestsXmls;
    ASSERT_EQ(ER_OK, XmlManifestConverter::ManifestsToXmlArray(manifests, ArraySize(manifests), manifestsXmlStrings));
    SecurityTestHelper::UnwrapStrings(manifestsXmlStrings, manifestsXmls);
    // Call UpdateIdentity on Peer 1 to install the cert chain
    ASSERT_EQ(ER_OK, peer1PC.UpdateIdentity(identityCertChain, certChainSize, manifestsXmls.data(), manifestsXmls.size()))
        << "Failed to update Identity cert or manifest ";

    // Create the intermediate certificate using peer2
    qcc::IdentityCertificate peer2Cert;
    peer2Cert.SetSerial((uint8_t*)"5678", 5);
    peer2Cert.SetIssuerCN(caCN, 4);
    peer2Cert.SetSubjectCN(leafCN, 4);
    validity.validFrom = qcc::GetEpochTimestamp() / 1000;
    validity.validTo = validity.validFrom + TEN_MINS;
    peer2Cert.SetValidity(&validity);

    KeyInfoNISTP256 peer2Key;
    PermissionConfigurator& peer2PC = peer2Bus.GetPermissionConfigurator();
    ASSERT_EQ(ER_OK, peer2PC.GetSigningPublicKey(peer2Key));

    peer2Cert.SetSubjectPublicKey(peer2Key.GetPublicKey());
    peer2Cert.SetAlias("peer2-cert-alias");
    peer2Cert.SetCA(true);

    //sign the leaf cert
    ASSERT_EQ(ER_OK, caPC.SignCertificate(peer2Cert));

    //We need identityCert chain CA1->Peer2
    identityCertChain[0] = peer2Cert;
    identityCertChain[1] = caCert;

    ASSERT_EQ(ER_OK, SecurityTestHelper::SignManifest(busUsedAsCA, identityCertChain[0], manifests[0]));
    ASSERT_EQ(ER_OK, XmlManifestConverter::ManifestsToXmlArray(manifests, ArraySize(manifests), manifestsXmlStrings));
    SecurityTestHelper::UnwrapStrings(manifestsXmlStrings, manifestsXmls);
    // Call UpdateIdentity on Peer 1 to install the cert chain
    ASSERT_EQ(ER_OK, peer2PC.UpdateIdentity(identityCertChain, certChainSize, manifestsXmls.data(), manifestsXmls.size()))
        << "Failed to update Identity cert or manifest ";

    ASSERT_EQ(ER_OK, ConnectBuses());
    uint32_t peer1ToPeer2SessionId;
    SessionOpts opts;
    ASSERT_EQ(ER_OK, peer1Bus.JoinSession(peer2Bus.GetUniqueName().c_str(), peer2SessionPort, NULL, peer1ToPeer2SessionId, opts));
    ProxyBusObject peer2Obj;
    peer2Obj = ProxyBusObject(peer1Bus, org::alljoyn::Bus::InterfaceName, org::alljoyn::Bus::ObjectPath, peer1ToPeer2SessionId, false);

    EXPECT_EQ(ER_OK, peer2Obj.IntrospectRemoteObject());
    ASSERT_EQ(ER_OK, busUsedAsCA.Stop());
    ASSERT_EQ(ER_OK, busUsedAsCA.Join());
    delete caAuthListener;
}

class PolicyRulesTestBusObject : public BusObject {
  public:
    PolicyRulesTestBusObject(BusAttachment& bus, const char* path, const char* interfaceName, bool announce = true)
        : BusObject(path), isAnnounced(announce), prop1(42), prop2(17) {
        const InterfaceDescription* iface = bus.GetInterface(interfaceName);
        EXPECT_TRUE(iface != NULL) << "NULL InterfaceDescription* for " << interfaceName;
        if (iface == NULL) {
            printf("The interfaceDescription pointer for %s was NULL when it should not have been.\n", interfaceName);
            return;
        }

        if (isAnnounced) {
            AddInterface(*iface, ANNOUNCED);
        } else {
            AddInterface(*iface, UNANNOUNCED);
        }

        /* Register the method handlers with the object */
        const MethodEntry methodEntries[] = {
            { iface->GetMember("Echo"), static_cast<MessageReceiver::MethodHandler>(&PolicyRulesTestBusObject::Echo) }
        };
        EXPECT_EQ(ER_OK, AddMethodHandlers(methodEntries, sizeof(methodEntries) / sizeof(methodEntries[0])));
    }

    void Echo(const InterfaceDescription::Member* member, Message& msg) {
        QCC_UNUSED(member);
        const MsgArg* arg((msg->GetArg(0)));
        QStatus status = MethodReply(msg, arg, 1);
        EXPECT_EQ(ER_OK, status) << "Echo: Error sending reply";
    }

    QStatus Get(const char* ifcName, const char* propName, MsgArg& val)
    {
        QCC_UNUSED(ifcName);
        QStatus status = ER_OK;
        if (0 == strcmp("Prop1", propName)) {
            val.Set("i", prop1);
        } else if (0 == strcmp("Prop2", propName)) {
            val.Set("i", prop2);
        } else {
            status = ER_BUS_NO_SUCH_PROPERTY;
        }
        return status;

    }

    QStatus Set(const char* ifcName, const char* propName, MsgArg& val)
    {
        QCC_UNUSED(ifcName);
        QStatus status = ER_OK;
        if ((0 == strcmp("Prop1", propName)) && (val.typeId == ALLJOYN_INT32)) {
            val.Get("i", &prop1);
        } else if ((0 == strcmp("Prop2", propName)) && (val.typeId == ALLJOYN_INT32)) {
            val.Get("i", &prop2);
        } else {
            status = ER_BUS_NO_SUCH_PROPERTY;
        }
        return status;
    }
    int32_t ReadProp1() {
        return prop1;
    }
  private:
    bool isAnnounced;
    int32_t prop1;
    int32_t prop2;
};

class MethodRulesTestValue {
  public:
    MethodRulesTestValue(uint8_t mask1, uint8_t mask2, bool makeMethodCall, bool respondToMethodCall) :
        peer1ActionMask(mask1),
        peer2ActionMask(mask2),
        proxyObjAllowedToCallMethod(makeMethodCall),
        busObjAllowedToRespondToMethodCall(respondToMethodCall) { }

    friend::std::ostream& operator<<(::std::ostream& os, const MethodRulesTestValue& val);
    uint8_t peer1ActionMask;
    uint8_t peer2ActionMask;
    bool proxyObjAllowedToCallMethod;
    bool busObjAllowedToRespondToMethodCall;
};

class SecurityOfflineManagementMethodCalls : public SecurityOfflineManagementTest,
    public testing::WithParamInterface<MethodRulesTestValue> {
};

TEST_P(SecurityOfflineManagementMethodCalls, PolicyRules)
{

    PolicyRulesTestBusObject peer2BusObject(peer2Bus, "/test", interfaceName);
    ASSERT_EQ(ER_OK, peer2Bus.RegisterBusObject(peer2BusObject));

    /* install permissions make method calls */
    //Permission policy that will be installed on peer1
    PermissionPolicy peer1Policy;
    peer1Policy.SetSerialNumber(1);
    {
        PermissionPolicy::Acl acls[1];
        {
            PermissionPolicy::Peer peers[1];
            peers[0].SetType(PermissionPolicy::Peer::PEER_ANY_TRUSTED);
            acls[0].SetPeers(1, peers);
        }
        {
            PermissionPolicy::Rule rules[1];
            rules[0].SetObjPath("/test");
            rules[0].SetInterfaceName(interfaceName);
            {
                PermissionPolicy::Rule::Member members[1];
                members[0].Set("Echo", PermissionPolicy::Rule::Member::METHOD_CALL, GetParam().peer1ActionMask);
                rules[0].SetMembers(1, members);
            }
            acls[0].SetRules(1, rules);
        }
        peer1Policy.SetAcls(1, acls);
    }

    // Permission policy that will be installed on peer2
    PermissionPolicy peer2Policy;
    peer2Policy.SetSerialNumber(1);
    {
        PermissionPolicy::Acl acls[1];
        {
            PermissionPolicy::Peer peers[1];
            peers[0].SetType(PermissionPolicy::Peer::PEER_ANY_TRUSTED);
            acls[0].SetPeers(1, peers);
        }
        {
            PermissionPolicy::Rule rules[1];
            rules[0].SetObjPath("*");
            rules[0].SetInterfaceName(interfaceName);
            {
                PermissionPolicy::Rule::Member members[1];
                members[0].Set("Echo",
                               PermissionPolicy::Rule::Member::METHOD_CALL,
                               GetParam().peer2ActionMask);
                rules[0].SetMembers(1, members);
            }
            acls[0].SetRules(1, rules);
        }
        peer2Policy.SetAcls(1, acls);
    }

    PermissionConfigurator& pcPeer1 = peer1Bus.GetPermissionConfigurator();
    PermissionConfigurator& pcPeer2 = peer2Bus.GetPermissionConfigurator();

    {
        PermissionPolicy peer1DefaultPolicy;
        ASSERT_EQ(ER_OK, pcPeer1.GetDefaultPolicy(peer1DefaultPolicy));
        SecurityTestHelper::UpdatePolicyWithValuesFromDefaultPolicy(peer1DefaultPolicy, peer1Policy);
    }
    {
        PermissionPolicy peer2DefaultPolicy;
        ASSERT_EQ(ER_OK, pcPeer2.GetDefaultPolicy(peer2DefaultPolicy));
        SecurityTestHelper::UpdatePolicyWithValuesFromDefaultPolicy(peer2DefaultPolicy, peer2Policy);
    }

    ASSERT_EQ(ER_OK, pcPeer1.UpdatePolicy(peer1Policy));
    ASSERT_EQ(ER_OK, pcPeer2.UpdatePolicy(peer2Policy));

    ASSERT_EQ(ER_OK, ConnectBuses());

    SessionOpts opts;
    SessionId peer1ToPeer2SessionId;
    ASSERT_EQ(ER_OK, peer1Bus.JoinSession(peer2Bus.GetUniqueName().c_str(), peer2SessionPort, NULL, peer1ToPeer2SessionId, opts));
    ASSERT_EQ(ER_OK, pcPeer1.GetPolicy(peer1Policy));
    ASSERT_EQ(ER_OK, pcPeer2.GetPolicy(peer2Policy));
    qcc::String p1policyStr = "\n----Peer1 Policy-----\n" + peer1Policy.ToString();
    SCOPED_TRACE(p1policyStr.c_str());
    qcc::String p2policyStr = "\n----Peer2 Policy-----\n" + peer2Policy.ToString();
    SCOPED_TRACE(p2policyStr.c_str());

    /* Create the ProxyBusObject and call the Echo method on the interface */
    ProxyBusObject proxy(peer1Bus, peer2Bus.GetUniqueName().c_str(), "/test", peer1ToPeer2SessionId, true);
    ASSERT_EQ(ER_OK, proxy.ParseXml(interface.c_str()));
    ASSERT_TRUE(proxy.ImplementsInterface(interfaceName)) << interface.c_str() << "\n" << interfaceName;
    MsgArg arg("s", "String that should be Echoed back.");
    Message replyMsg(peer1Bus);
    QStatus methodCallStatus = proxy.MethodCall(interfaceName, "Echo", &arg, static_cast<size_t>(1), replyMsg);

    if (GetParam().proxyObjAllowedToCallMethod && GetParam().busObjAllowedToRespondToMethodCall) {
        EXPECT_EQ(ER_OK, methodCallStatus);
        char* echoReply;
        replyMsg->GetArg(0)->Get("s", &echoReply);
        EXPECT_STREQ("String that should be Echoed back.", echoReply);
    } else if (GetParam().proxyObjAllowedToCallMethod && !GetParam().busObjAllowedToRespondToMethodCall) {
        EXPECT_EQ(ER_PERMISSION_DENIED, methodCallStatus);
        EXPECT_STREQ("org.alljoyn.Bus.Security.Error.PermissionDenied", replyMsg->GetErrorName());
    } else { //!GetParam().proxyObjAllowedToCallMethod
        EXPECT_EQ(ER_PERMISSION_DENIED, methodCallStatus);
        EXPECT_STREQ("org.alljoyn.Bus.ErStatus", replyMsg->GetErrorName());
        EXPECT_EQ(ER_PERMISSION_DENIED, (QStatus)replyMsg->GetArg(1)->v_uint16) << "\n" << replyMsg->GetArg(0)->ToString().c_str() << "\n" << replyMsg->GetArg(1)->ToString().c_str();
    }

    /* clean up */
    peer2Bus.UnregisterBusObject(peer2BusObject);
}

INSTANTIATE_TEST_CASE_P(Method, SecurityOfflineManagementMethodCalls,
                        ::testing::Values(
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_PROVIDE, //0
                                                 PermissionPolicy::Rule::Member::ACTION_PROVIDE,
                                                 true, //Proxy object allowed to make method call
                                                 false), //bus object allowed to respond to method call
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_PROVIDE, //1
                                                 PermissionPolicy::Rule::Member::ACTION_MODIFY,
                                                 true,
                                                 true),
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_PROVIDE, //2
                                                 PermissionPolicy::Rule::Member::ACTION_OBSERVE,
                                                 true,
                                                 false),
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_MODIFY, //3
                                                 PermissionPolicy::Rule::Member::ACTION_PROVIDE,
                                                 false,
                                                 false),
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_MODIFY, //4
                                                 PermissionPolicy::Rule::Member::ACTION_MODIFY,
                                                 false,
                                                 true),
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_MODIFY, //5
                                                 PermissionPolicy::Rule::Member::ACTION_OBSERVE,
                                                 false,
                                                 false),
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_OBSERVE, //6
                                                 PermissionPolicy::Rule::Member::ACTION_PROVIDE,
                                                 false,
                                                 false),
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_OBSERVE, //7
                                                 PermissionPolicy::Rule::Member::ACTION_MODIFY,
                                                 false,
                                                 true),
                            MethodRulesTestValue(PermissionPolicy::Rule::Member::ACTION_OBSERVE, //8
                                                 PermissionPolicy::Rule::Member::ACTION_OBSERVE,
                                                 false,
                                                 false)
                            ));
