////////////////////////////////////////////////////////////////////////////////
// Copyright AllSeen Alliance. All rights reserved.
//
//    Permission to use, copy, modify, and/or distribute this software for any
//    purpose with or without fee is hereby granted, provided that the above
//    copyright notice and this permission notice appear in all copies.
//
//    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
//    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
//    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
////////////////////////////////////////////////////////////////////////////////

#import <XCTest/XCTest.h>

#import "AJNInit.h"
#import "AJNBusAttachment.h"
#import "AJNInterfaceDescription.h"
#import "SecureObject.h"
#import "BasicObject.h"
#import "AJNSecurityApplicationProxy.h"

/* keys and certificates were taken from Java Unit test - AuthListenerECDHETTest */

/* the key and certificate is generated using openssl */

static NSString *const kClientEcdsaPrivateKeyPEM =
@"-----BEGIN EC PRIVATE KEY-----\n\
MHcCAQEEIBiLw29bf669g7MxMbXK2u8Lp5//w7o4OiVGidJdKAezoAoGCCqGSM49\n\
AwEHoUQDQgAE+A0C9YTghZ1vG7198SrUHxFlhtbSsmhbwZ3N5aQRwzFXWcCCm38k\n\
OzJEmS+venmF1o/FV0W80Mcok9CWlV2T6A==\n\
-----END EC PRIVATE KEY-----";

/* these keys were generated by the unit test common/unit_test/CertificateECCTest.GenSelfSignECCX509CertForBBservice */

static NSString *const kClientEcdsaCertChainX509PEM =
@"-----BEGIN CERTIFICATE-----\n\
MIIBYTCCAQigAwIBAgIJAOVrhhJOre/7MAoGCCqGSM49BAMCMCQxIjAgBgNVBAoM\n\
GUFsbEpveW5UZXN0U2VsZlNpZ25lZE5hbWUwHhcNMTUwODI0MjAxODQ1WhcNMjkw\n\
NTAyMjAxODQ1WjAgMR4wHAYDVQQKDBVBbGxKb3luVGVzdENsaWVudE5hbWUwWTAT\n\
BgcqhkjOPQIBBggqhkjOPQMBBwNCAAT4DQL1hOCFnW8bvX3xKtQfEWWG1tKyaFvB\n\
nc3lpBHDMVdZwIKbfyQ7MkSZL696eYXWj8VXRbzQxyiT0JaVXZPooycwJTAVBgNV\n\
HSUEDjAMBgorBgEEAYLefAEBMAwGA1UdEwEB/wQCMAAwCgYIKoZIzj0EAwIDRwAw\n\
RAIgevLUXoJBgUr6nVepBHQiv85CGuxu00V4uoARbH6qu1wCIA54iDRh6wit1zbP\n\
kqkBC015LjxucTf3Y7lNGhXuZRsL\n\
-----END CERTIFICATE-----\n\
-----BEGIN CERTIFICATE-----\n\
MIIBdTCCARugAwIBAgIJAJTFhmdwDWsvMAoGCCqGSM49BAMCMCQxIjAgBgNVBAoM\n\
GUFsbEpveW5UZXN0U2VsZlNpZ25lZE5hbWUwHhcNMTUwODI0MjAxODQ1WhcNMjkw\n\
NTAyMjAxODQ1WjAkMSIwIAYDVQQKDBlBbGxKb3luVGVzdFNlbGZTaWduZWROYW1l\n\
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEF0nZmkzuK/2CVf7udexLZnlEB5D+\n\
DBsx3POtsRyZWm2QiI1untDTp0uYp51tkP6wI6Gi5gWxB+86lEIPg4ZpTaM2MDQw\n\
IQYDVR0lBBowGAYKKwYBBAGC3nwBAQYKKwYBBAGC3nwBBTAPBgNVHRMBAf8EBTAD\n\
AQH/MAoGCCqGSM49BAMCA0gAMEUCIQDPQ1VRvdBhhneU5e7OvIFHK3d9XPZA7Fw6\n\
VyeW/P5wIAIgD969ks/z9vQ1yCaVaxmVz63toC1ggp4AnBXqbDy8O+4=\n\
-----END CERTIFICATE-----";

static NSString *const kServerEcdsaPrivateKeyPEM =
@"-----BEGIN EC PRIVATE KEY-----\n\
MDECAQEEII9KTdqfje8CzLnQ0asUaVdW1hmjQrP1AINRd03fdTAloAoGCCqGSM49\n\
AwEH\n\
-----END EC PRIVATE KEY-----";

static NSString *const kServerEcdsaCertChainX509PEM =
@"-----BEGIN CERTIFICATE-----\n\
MIIBtTCCAVugAwIBAgIHMTAxMDEwMTAKBggqhkjOPQQDAjBCMRUwEwYDVQQLDAxv\n\
cmdhbml6YXRpb24xKTAnBgNVBAMMIDAyMzRjYjFhMmRlYmY5OTBmZGQ0NGJmZjlh\n\
MjhjZDUxMB4XDTE1MDgyMTIyMjEwNloXDTI1MDgxODIyMjEwNlowQjEVMBMGA1UE\n\
CwwMb3JnYW5pemF0aW9uMSkwJwYDVQQDDCBjN2UzYmRmNzhlOWRmNmRkOTk3N2Q4\n\
NGUwMTE0MDYwMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEjL84d4YPMMH5g9\n\
kq5ErdTO4ouaGWLz7ikerB+HLPAu+aTekMxoA7uIejr5iekcWXxryJIxFwsdGh34\n\
hl9YQKGjPDA6MAwGA1UdEwQFMAMBAf8wFQYDVR0lBA4wDAYKKwYBBAGC3nwBATAT\n\
BgNVHSMEDDAKoAhCmX6GR09OkTAKBggqhkjOPQQDAgNIADBFAiEA026qDcGfTife\n\
D75dbuT6MFz+sT8xuEkYNxyshK8vBMECIAa5lvbBATlTHSrb0FHg+jwFnQ2yYUE/\n\
aFFhPrtFbwHn\n\
-----END CERTIFICATE-----";

static NSString *const kManifestTemplate =
@"<manifest>\
<node name=\"*\">\
<interface name=\"*\">\
<any name=\"*\">\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Provide\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Observe\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Modify\"/>\
</any>\
</interface>\
</node>\
</manifest>";

static NSString *const kManifestAllInclusive =
@"<manifest>\
<node name=\"*\">\
<interface name=\"*\">\
<method name=\"*\">\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Provide\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Modify\"/>\
</method>\
<signal name=\"*\">\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Provide\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Observe\"/>\
</signal>\
<property name=\"*\">\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Provide\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Observe\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Modify\"/>\
</property>\
</interface>\
</node>\
</manifest>";

static NSString *const kPolicy =
@"<policy>\
<policyVersion>1</policyVersion>\
<serialNumber>2</serialNumber>\
<acls>\
<acl>\
<peers>\
<peer>\
<type>ALL</type>\
</peer>\
</peers>\
<rules>\
<node name=\"*\">\
<interface name=\"org.alljoyn.bus.unittests.secure.SecureInterface\">\
<method name=\"*\">\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Modify\"/>\
</method>\
<signal name=\"*\">\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Provide\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Observe\"/>\
</signal>\
<property name=\"*\">\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Observe\"/>\
<annotation name=\"org.alljoyn.Bus.Action\" value=\"Modify\"/>\
</property>\
</interface>\
</node>\
</rules>\
</acl>\
</acls>\
</policy>";

static NSString *const kCorrenctPassword = @"1234";
static NSString *const kInCorrenctPassword = @"4321";

NSString *currentDir;

NSString *const kSecureObjectPath = @"/SecureObject";

NSString *const kSecureServiceName = @"org.alljoyn.unittests";

AJNSessionPort const kSessionDefaultPort = 42;

typedef enum AuthenticationState {kInitState, kAuthFailed, kAuthSuccess} AuthenticationState;

@interface SecureTests : XCTestCase <AJNAuthenticationListener, AJNSessionListener, AJNSessionPortListener, AJNApplicationStateListener>

@property (nonatomic, strong) AJNBusAttachment *managerBus;
@property (nonatomic, strong) AJNBusAttachment *bus;
@property (nonatomic) BOOL isTestClient;
@property (nonatomic) BOOL isWrongPasswordMustBeUsed;
@property (nonatomic) AuthenticationState authenticationState;
@property (nonnull, strong) AJNGUID128 *managerGuid;

@end

@implementation SecureTests

+ (void)setUp {
    NSFileManager *fileManager = [[NSFileManager alloc] init];
    currentDir = [fileManager currentDirectoryPath];
}

- (void)setUp {
    [super setUp];

    [AJNInit alljoynInit];
    [AJNInit alljoynRouterInit];
}

- (void)tearDown {
    [AJNInit alljoynRouterShutdown];
    [AJNInit alljoynShutdown];

    [super tearDown];
}

- (void)alljoynServiceOn
{
    self.managerBus = [[AJNBusAttachment alloc] initWithApplicationName:@"testManagerApp" allowRemoteMessages:YES];
    self.bus = [[AJNBusAttachment alloc] initWithApplicationName:@"testServiceApp" allowRemoteMessages:YES];
    self.isTestClient = NO;
    self.isWrongPasswordMustBeUsed = NO;
    self.authenticationState = kInitState;
    self.managerGuid = [[AJNGUID128 alloc] init];
}

- (void)alljoynServiceOff
{
    self.managerBus = nil;
    self.bus = nil;
}

- (void)alljoynClientOn
{
    self.bus = [[AJNBusAttachment alloc] initWithApplicationName:@"testClientApp" allowRemoteMessages:YES];
    self.isTestClient = YES;
    self.isWrongPasswordMustBeUsed = NO;
    self.authenticationState = kInitState;
}

- (void)alljoynClientOff
{
    self.bus = nil;
}

- (NSArray *)createIdentityCertWithSerial:(NSString *)serial publicKey:(AJNECCPublicKey *)pubKey alias:(NSString *)alias expirationTimeInSeconds:(NSNumber *)expiration busAttachment:(AJNBusAttachment *)bus
{
    AJNPermissionConfigurator *permissionConfigurator = [bus permissionConfigurator];

    AJNCertificateX509 *identityCertificate = [[AJNCertificateX509 alloc] initWithCertificateType:IDENTITY_CERTIFICATE];

    NSData *serialData = [serial dataUsingEncoding:NSUTF8StringEncoding];
    [identityCertificate setSerial:[serialData mutableCopy]];

    [identityCertificate setIssuerCN:[[NSMutableData alloc] initWithBytes:self.managerGuid.bytes length:AJNGUID128.SIZE]];

    NSString *busName = [bus.uniqueName copy];
    NSData *busNameData = [busName dataUsingEncoding:NSUTF8StringEncoding];
    [identityCertificate setSubjectCN:[busNameData mutableCopy]];

    [identityCertificate setSubjectPublicKey:pubKey];

    [identityCertificate setSubjectAltName:[alias mutableCopy]];

    AJNValidPeriod validPeriod;
    validPeriod.validFrom = [[NSDate date] timeIntervalSince1970];
    validPeriod.validTo = [[NSDate date] timeIntervalSince1970] + [expiration doubleValue];

    [identityCertificate setValidity:&validPeriod];

    [permissionConfigurator signCertificate:identityCertificate];

    AJNKeyInfoNISTP256 *keyInfo;
    [permissionConfigurator getSigningPublicKey:&keyInfo];

    AJNECCPublicKey *busPublicKey = [keyInfo publicKey];

    [identityCertificate verifyWithPublicKey:busPublicKey];

    [identityCertificate verifyValidity];

    NSArray *identityCertificateChain = [[NSArray alloc] initWithObjects:identityCertificate, nil];

    return identityCertificateChain;
}

- (QStatus)installMembershipOnManager:(AJNSecurityApplicationProxy *)securityApplicationProxy alias:(NSString *)alias expirationTimeInSeconds:(NSNumber *)expiration
{
    if (self.isTestClient == YES) {
        return ER_NONE;
    }

    AJNPermissionConfigurator *managerPermissionConfigurator = self.managerBus.permissionConfigurator;

    AJNKeyInfoNISTP256 *managerKey;
    [managerPermissionConfigurator getSigningPublicKey:&managerKey];

    AJNCertificateX509 *managerMemberCert = [[AJNCertificateX509 alloc] initWithCertificateType:MEMBERSHIP_CERTIFICATE];

    NSData *serialData = [@"2" dataUsingEncoding:NSUTF8StringEncoding];
    [managerMemberCert setSerial:[serialData mutableCopy]];

    [managerMemberCert setIssuerCN:[[NSMutableData alloc] initWithBytes:self.managerGuid.bytes length:AJNGUID128.SIZE]];

    NSString *busName = [self.managerBus.uniqueName copy];
    NSData *busNameData = [busName dataUsingEncoding:NSUTF8StringEncoding];
    [managerMemberCert setSubjectCN:[busNameData mutableCopy]];

    [managerMemberCert setSubjectPublicKey:managerKey.publicKey];

    [managerMemberCert setGuild:[self.managerGuid getGuidData]];

    [managerMemberCert setCA:NO];

    AJNValidPeriod validPeriod;
    validPeriod.validFrom = [[NSDate date] timeIntervalSince1970];
    validPeriod.validTo = [[NSDate date] timeIntervalSince1970] + [expiration doubleValue];

    [managerMemberCert setValidity:&validPeriod];

    [managerPermissionConfigurator signCertificate:managerMemberCert];

    QStatus status = [managerMemberCert verifyWithPublicKey:managerKey.publicKey];
    if (status == ER_OK) {
        status = ER_NONE;
        status = [securityApplicationProxy installMembership:[[NSArray alloc] initWithObjects:managerMemberCert, nil]];
    }

    return status;
}

- (void)testSecureMethodCallEcdhePsk
{
    [self alljoynServiceOn];

    QStatus status = ER_OK;

    SecureTests *client = [[SecureTests alloc] init];
    [client alljoynClientOn];

    status = [self.bus start];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to start.");
    status = [self.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to connect with null argument.");

    status = [client.bus start];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to start.");
    status = [client.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to connect with null argument.");

    SecureObject *secureObject = [[SecureObject alloc] initWithBusAttachment:self.bus onPath:kSecureObjectPath];

    status = [self.bus registerBusObject:secureObject enableSecurity:YES];
    XCTAssertTrue(status == ER_OK, @"Unable to register secure bus object.");

    status = [self.bus requestWellKnownName:kSecureServiceName withFlags:kAJNBusNameFlagDoNotQueue|kAJNBusNameFlagReplaceExisting];
    XCTAssertTrue(status == ER_OK, @"Failed to get well known name");

    //enable peer security
    status = [self.bus enablePeerSecurity:@"ALLJOYN_ECDHE_PSK" authenticationListener:self keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"serviceBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to enable peer security.");

    status = [client.bus enablePeerSecurity:@"ALLJOYN_ECDHE_PSK" authenticationListener:client keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"clientBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to enable peer security.");

    AJNSessionOptions *sessionOptions = [[AJNSessionOptions alloc] init];

    status = [self.bus bindSessionOnPort:kSessionDefaultPort withOptions:sessionOptions withDelegate:self];
    XCTAssertTrue(status == ER_OK, @"Bind service session on port %ld failed.", (long)kSessionDefaultPort);

    AJNSessionId sessionId = [client.bus joinSessionWithName:kSecureServiceName onPort:kSessionDefaultPort withDelegate:self options:sessionOptions];
    XCTAssertTrue(sessionId > 0, @"Client joun service session on port %ld failed.", (long)kSessionDefaultPort);

    SecureObjectProxy *secureProxyObject = [[SecureObjectProxy alloc] initWithBusAttachment:client.bus serviceName:kSecureServiceName objectPath:kSecureObjectPath sessionId:sessionId enableSecurity:YES];

    [secureProxyObject introspectRemoteObject];

    NSString *concatenatedString = [secureProxyObject concatenateString:@"Foo " withString:@"bar"];
    NSString *expectedString = @"Foo bar";
    XCTAssertTrue([expectedString compare:concatenatedString] == NSOrderedSame, @"Unexpected concatenated strings. Value is [%@], have to be [%@]", concatenatedString, expectedString);

    XCTAssertTrue(self.authenticationState == kAuthSuccess, @"Auth on service side was failed.");
    XCTAssertTrue(client.authenticationState == kAuthSuccess, @"Auth on service side was failed.");

    //turn off all
    [self.bus clearKeyStore];
    status = [self.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to disconnect.");
    status = [self.bus stop];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to stop.");

    [client.bus clearKeyStore];
    status = [client.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to disconnect.");
    status = [client.bus stop];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to stop.");
}

- (void)testSecureMethodCallEcdhePskWrongClientPassword
{
    [self alljoynServiceOn];

    QStatus status = ER_OK;

    SecureTests *client = [[SecureTests alloc] init];
    [client alljoynClientOn];
    client.isWrongPasswordMustBeUsed = YES;

    status = [self.bus start];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to start.");
    status = [self.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to connect with null argument.");

    status = [client.bus start];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to start.");
    status = [client.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to connect with null argument.");

    SecureObject *secureObject = [[SecureObject alloc] initWithBusAttachment:self.bus onPath:kSecureObjectPath];

    status = [self.bus registerBusObject:secureObject enableSecurity:YES];
    XCTAssertTrue(status == ER_OK, @"Unable to register secure bus object.");

    status = [self.bus requestWellKnownName:kSecureServiceName withFlags:kAJNBusNameFlagDoNotQueue|kAJNBusNameFlagReplaceExisting];
    XCTAssertTrue(status == ER_OK, @"Failed to get well known name");

    //enable peer security
    status = [self.bus enablePeerSecurity:@"ALLJOYN_ECDHE_PSK" authenticationListener:self keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"serviceBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to enable peer security.");

    status = [client.bus enablePeerSecurity:@"ALLJOYN_ECDHE_PSK" authenticationListener:client keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"clientBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to enable peer security.");

    AJNSessionOptions *sessionOptions = [[AJNSessionOptions alloc] init];

    status = [self.bus bindSessionOnPort:kSessionDefaultPort withOptions:sessionOptions withDelegate:self];
    XCTAssertTrue(status == ER_OK, @"Bind service session on port %ld failed.", (long)kSessionDefaultPort);

    AJNSessionId sessionId = [client.bus joinSessionWithName:kSecureServiceName onPort:kSessionDefaultPort withDelegate:self options:sessionOptions];
    XCTAssertTrue(sessionId > 0, @"Client joun service session on port %ld failed.", (long)kSessionDefaultPort);

    SecureObjectProxy *secureProxyObject = [[SecureObjectProxy alloc] initWithBusAttachment:client.bus serviceName:kSecureServiceName objectPath:kSecureObjectPath sessionId:sessionId enableSecurity:YES];

    status = [secureProxyObject introspectRemoteObject];

    NSString *concatenatedString = [secureProxyObject concatenateString:@"Foo " withString:@"bar"];
    NSString *expectedString = @"(null)";
    XCTAssertTrue(concatenatedString == nil, @"Unexpected concatenated strings. Value is [%@], have to be [%@]", concatenatedString, expectedString);

    XCTAssertTrue(self.authenticationState == kAuthFailed, @"Auth on service side was passed (wrong client password was used).");
    XCTAssertTrue(client.authenticationState == kAuthFailed, @"Auth on service side was passed (wrong client password was used).");

    //turn off all
    [self.bus clearKeyStore];
    status = [self.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to disconnect.");
    status = [self.bus stop];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to stop.");

    [client.bus clearKeyStore];
    status = [client.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to disconnect.");
    status = [client.bus stop];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to stop.");
}

- (void)testSecureMethodCallEcdheEcdsa
{
    [self alljoynServiceOn];

    QStatus status = ER_OK;

    SecureTests *client = [[SecureTests alloc] init];
    [client alljoynClientOn];

    status = [self.bus start];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to start.");
    status = [self.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to connect with null argument.");

    status = [client.bus start];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to start.");
    status = [client.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to connect with null argument.");

    SecureObject *secureObject = [[SecureObject alloc] initWithBusAttachment:self.bus onPath:kSecureObjectPath];

    status = [self.bus registerBusObject:secureObject enableSecurity:YES];
    XCTAssertTrue(status == ER_OK, @"Unable to register secure bus object.");

    status = [self.bus requestWellKnownName:kSecureServiceName withFlags:kAJNBusNameFlagDoNotQueue|kAJNBusNameFlagReplaceExisting];
    XCTAssertTrue(status == ER_OK, @"Failed to get well known name");

    //enable peer security
    status = [self.bus enablePeerSecurity:@"ALLJOYN_ECDHE_ECDSA" authenticationListener:self keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"serviceBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to enable peer security.");
    [self.bus clearKeyStore];

    status = [client.bus enablePeerSecurity:@"ALLJOYN_ECDHE_ECDSA" authenticationListener:client keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"clientBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to enable peer security.");
    [client.bus clearKeyStore];

    AJNSessionOptions *sessionOptions = [[AJNSessionOptions alloc] init];

    status = [self.bus bindSessionOnPort:kSessionDefaultPort withOptions:sessionOptions withDelegate:self];
    XCTAssertTrue(status == ER_OK, @"Bind service session on port %ld failed.", (long)kSessionDefaultPort);

    AJNSessionId sessionId = [client.bus joinSessionWithName:kSecureServiceName onPort:kSessionDefaultPort withDelegate:self options:sessionOptions];
    XCTAssertTrue(sessionId > 0, @"Client joun service session on port %ld failed.", (long)kSessionDefaultPort);

    SecureObjectProxy *secureProxyObject = [[SecureObjectProxy alloc] initWithBusAttachment:client.bus serviceName:kSecureServiceName objectPath:kSecureObjectPath sessionId:sessionId enableSecurity:YES];

    [secureProxyObject introspectRemoteObject];

    NSString *concatenatedString = [secureProxyObject concatenateString:@"Foo " withString:@"bar"];
    NSString *expectedString = @"Foo bar";
    XCTAssertTrue([expectedString compare:concatenatedString] == NSOrderedSame, @"Unexpected concatenated strings. Value is [%@], have to be [%@]", concatenatedString, expectedString);

    XCTAssertTrue(self.authenticationState == kAuthSuccess, @"Auth on service side was failed.");
    XCTAssertTrue(client.authenticationState == kAuthSuccess, @"Auth on service side was failed.");

    //turn off all
    status = [self.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to disconnect.");
    status = [self.bus stop];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to stop.");

    status = [client.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to disconnect.");
    status = [client.bus stop];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to stop.");
}

- (void)testSecureMethodCallWithSecurityManager
{
    [self alljoynServiceOn];

    QStatus status = ER_OK;

    SecureTests *client = [[SecureTests alloc] init];
    [client alljoynClientOn];

    status = [self.managerBus start];
    XCTAssertTrue(status == ER_OK, @"Manager bus failed to start.");
    status = [self.managerBus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Manager bus failed to connect with null argument.");

    status = [self.bus start];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to start.");
    status = [self.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to connect with null argument.");

    status = [client.bus start];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to start.");
    status = [client.bus connectWithArguments:@"null"];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to connect with null argument.");

    //enable peer security
    status = [self.managerBus enablePeerSecurity:@"ALLJOYN_ECDHE_NULL ALLJOYN_ECDHE_ECDSA" authenticationListener:self keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"managerBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Manager bus failed to enable peer security.");

    status = [self.bus enablePeerSecurity:@"ALLJOYN_ECDHE_NULL ALLJOYN_ECDHE_ECDSA" authenticationListener:self keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"serviceBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to enable peer security.");

    status = [client.bus enablePeerSecurity:@"ALLJOYN_ECDHE_NULL ALLJOYN_ECDHE_ECDSA" authenticationListener:client keystoreFileName:[NSString stringWithFormat:@"%@/%@", currentDir, @"clientBusKeystore"] sharing:YES];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to enable peer security.");

    //create and register Object on service
    SecureObject *secureObject = [[SecureObject alloc] initWithBusAttachment:self.bus onPath:kSecureObjectPath];

    status = [self.bus registerBusObject:secureObject enableSecurity:YES];
    XCTAssertTrue(status == ER_OK, @"Unable to register secure bus object.");

    //Bind ports
    AJNSessionOptions *sessionOptions = [[AJNSessionOptions alloc] init];

    status = [self.bus bindSessionOnPort:kSessionDefaultPort withOptions:sessionOptions withDelegate:self];
    XCTAssertTrue(status == ER_OK, @"Bind service session on port %ld failed.", (long)kSessionDefaultPort);

    status = [self.managerBus bindSessionOnPort:kSessionDefaultPort withOptions:sessionOptions withDelegate:self];
    XCTAssertTrue(status == ER_OK, @"Bind manager session on port %ld failed.", (long)kSessionDefaultPort);

    status = [client.bus bindSessionOnPort:kSessionDefaultPort withOptions:sessionOptions withDelegate:self];
    XCTAssertTrue(status == ER_OK, @"Bind service session on port %ld failed.", (long)kSessionDefaultPort);

    //Join session
    AJNSessionId managerSessionId = [self.managerBus joinSessionWithName:[self.managerBus uniqueName] onPort:kSessionDefaultPort withDelegate:self options:sessionOptions];
    XCTAssertTrue(managerSessionId > 0, @"ManagerBus join sesseion on port %ld failed.", (long)kSessionDefaultPort); //TODO for what ???

    AJNSessionId serviceSessionId = [self.managerBus joinSessionWithName:[self.bus uniqueName] onPort:kSessionDefaultPort withDelegate:self options:sessionOptions];
    XCTAssertTrue(serviceSessionId > 0, @"ManagerBus join sesseion on port %ld failed.", (long)kSessionDefaultPort);

    AJNSessionId clientSessionId = [self.managerBus joinSessionWithName:[client.bus uniqueName] onPort:kSessionDefaultPort withDelegate:self options:sessionOptions];
    XCTAssertTrue(clientSessionId > 0, @"ManagerBus join sesseion on port %ld failed.", (long)kSessionDefaultPort);

    //Create securityApplication
    AJNSecurityApplicationProxy *serviceProxyApplication = [[AJNSecurityApplicationProxy alloc] initWithBus:self.managerBus withBusName:[self.bus uniqueName] inSession:serviceSessionId];
    AJNSecurityApplicationProxy *clientProxyApplication = [[AJNSecurityApplicationProxy alloc] initWithBus:self.managerBus withBusName:[client.bus uniqueName] inSession:clientSessionId];
    AJNSecurityApplicationProxy *managerProxyApplication = [[AJNSecurityApplicationProxy alloc] initWithBus:self.managerBus withBusName:[self.managerBus uniqueName] inSession:managerSessionId];

    //The State signal is only emitted if manifest template is installed
    status = [[self.managerBus permissionConfigurator] setManifestTemplateFromXml:kManifestTemplate];
    XCTAssertTrue(status == ER_OK, @"Setting manifest template from xml for manager bus failed.");

    status = [[self.bus permissionConfigurator] setManifestTemplateFromXml:kManifestTemplate];
    XCTAssertTrue(status == ER_OK, @"Setting manifest template from xml for service bus failed.");

    status = [[client.bus permissionConfigurator] setManifestTemplateFromXml:kManifestTemplate];
    XCTAssertTrue(status == ER_OK, @"Setting manifest template from xml for client bus failed.");

    //Create admin group key
    AJNKeyInfoNISTP256 *managerPublicKeyInfo;
    status = [[self.managerBus permissionConfigurator] getSigningPublicKey:&managerPublicKeyInfo];
    XCTAssertTrue(status == ER_OK, @"Geting of public key of manager application failed.");

    AJNKeyInfoNISTP256 *servicePublicKeyInfo;
    status = [[self.bus permissionConfigurator] getSigningPublicKey:&servicePublicKeyInfo];
    XCTAssertTrue(status == ER_OK, @"Geting of public key of service application failed.");

    AJNKeyInfoNISTP256 *clientPublicKeyInfo;
    status = [[client.bus permissionConfigurator] getSigningPublicKey:&clientPublicKeyInfo];
    XCTAssertTrue(status == ER_OK, @"Geting of public key of client application failed.");

    //Claim capability
    AJNClaimCapabilities claimCapabilities;

    status = [[self.managerBus permissionConfigurator] setClaimCapabilities:CAPABLE_ECDHE_NULL];
    [[self.managerBus permissionConfigurator] getClaimCapabilities:&claimCapabilities];
    XCTAssertTrue(claimCapabilities == CAPABLE_ECDHE_NULL && status == ER_OK, @"Setting claim capability for client bus failed.");

    status = [[self.bus permissionConfigurator] setClaimCapabilities:CAPABLE_ECDHE_NULL];
    [[self.bus permissionConfigurator] getClaimCapabilities:&claimCapabilities];
    XCTAssertTrue(claimCapabilities == CAPABLE_ECDHE_NULL && status == ER_OK, @"Setting claim capability for client bus failed.");

    status = [[client.bus permissionConfigurator] setClaimCapabilities:CAPABLE_ECDHE_NULL];
    [[client.bus permissionConfigurator] getClaimCapabilities:&claimCapabilities];
    XCTAssertTrue(claimCapabilities == CAPABLE_ECDHE_NULL && status == ER_OK, @"Setting claim capability for service bus failed.");


    AJNClaimCapabilityAdditionalInfo claimCapabilityAddInfo;

    status = [[self.bus permissionConfigurator] setClaimCapabilityAdditionalInfo:PSK_GENERATED_BY_SECURITY_MANAGER];
    [[self.bus permissionConfigurator] getClaimCapabilityAdditionalInfo:&claimCapabilityAddInfo];
    XCTAssertTrue(claimCapabilityAddInfo == PSK_GENERATED_BY_SECURITY_MANAGER && status == ER_OK, @"Seting claim capability additional info for service bus failed.");

    status = [[client.bus permissionConfigurator] setClaimCapabilityAdditionalInfo:PSK_GENERATED_BY_SECURITY_MANAGER];
    [[client.bus permissionConfigurator] getClaimCapabilityAdditionalInfo:&claimCapabilityAddInfo];
    XCTAssertTrue(claimCapabilityAddInfo == PSK_GENERATED_BY_SECURITY_MANAGER && status == ER_OK, @"Seting claim capability additional info for client bus failed.");

    //register Lisener
    status = [self.bus registerApplicationStateListener:self];
    XCTAssertTrue(status == ER_OK, @"Failed to register application state listener for service bus.");

    status = [client.bus registerApplicationStateListener:client];
    XCTAssertTrue(status == ER_OK, @"Failed to register application state listener for client bus.");

    //Check claim status
    AJNApplicationState serviceApplicationStateBeforeClaiming;
    [[self.bus permissionConfigurator] getApplicationState:&serviceApplicationStateBeforeClaiming];
    XCTAssertTrue(serviceApplicationStateBeforeClaiming == CLAIMABLE, @"Service wasn't been claimed.");

    AJNApplicationState clientApplicationStateBeforeClaiming;
    [[client.bus permissionConfigurator] getApplicationState:&clientApplicationStateBeforeClaiming];
    XCTAssertTrue(clientApplicationStateBeforeClaiming == CLAIMABLE, @"Service wasn't been claimed.");

    //claim Manager
    NSArray *identityCertificateChain;
    NSString *signedManifest;

    identityCertificateChain = [self createIdentityCertWithSerial:@"0" publicKey:managerPublicKeyInfo.publicKey alias:@"ManagerAlias" expirationTimeInSeconds:[[NSNumber alloc] initWithDouble:3600] busAttachment:self.managerBus];
    XCTAssertFalse(identityCertificateChain == nil, @"Failed to create identity cert for manager app.");

    signedManifest = [kManifestAllInclusive copy];

    status = [[self.managerBus permissionConfigurator] computeThumbprintAndSignManifestXml:(AJNCertificateX509 *)[identityCertificateChain objectAtIndex:0] manifestXml:&signedManifest];
    XCTAssertTrue(status == ER_OK, @"Failed to compute thumbprint and sign manifest XML.");

    status = [managerProxyApplication claim:managerPublicKeyInfo adminGroupId:self.managerGuid adminGroup:managerPublicKeyInfo identityCertChain:identityCertificateChain manifestsXmls:[[NSArray alloc] initWithObjects: signedManifest, nil]];
    XCTAssertTrue(status == ER_OK, @"Failed to claim manager application.");

    //claim Service
    identityCertificateChain = [self createIdentityCertWithSerial:@"1" publicKey:servicePublicKeyInfo.publicKey alias:@"ServiceAlias" expirationTimeInSeconds:[[NSNumber alloc] initWithDouble:3600] busAttachment:self.managerBus];
    XCTAssertFalse(identityCertificateChain == nil, @"Failed to create identity cert for service app.");

    signedManifest = [kManifestAllInclusive copy];

    status = [[self.managerBus permissionConfigurator] computeThumbprintAndSignManifestXml:(AJNCertificateX509 *)[identityCertificateChain objectAtIndex:0] manifestXml:&signedManifest];
    XCTAssertTrue(status == ER_OK, @"Failed to compute thumbprint and sign manifest XML.");

    status = [serviceProxyApplication claim:managerPublicKeyInfo adminGroupId:self.managerGuid adminGroup:managerPublicKeyInfo identityCertChain:identityCertificateChain manifestsXmls:[[NSArray alloc] initWithObjects: signedManifest, nil]];
    XCTAssertTrue(status == ER_OK, @"Failed to claim service application.");

    //claim Client
    identityCertificateChain = [self createIdentityCertWithSerial:@"2" publicKey:clientPublicKeyInfo.publicKey alias:@"ClientAlias" expirationTimeInSeconds:[[NSNumber alloc] initWithDouble:3600] busAttachment:self.managerBus];
    XCTAssertFalse(identityCertificateChain == nil, @"Failed to create identity cert for client app.");

    signedManifest = [kManifestAllInclusive copy];

    status = [[self.managerBus permissionConfigurator] computeThumbprintAndSignManifestXml:(AJNCertificateX509 *)[identityCertificateChain objectAtIndex:0] manifestXml:&signedManifest];
    XCTAssertTrue(status == ER_OK, @"Failed to compute thumbprint and sign manifest XML.");

    status = [clientProxyApplication claim:managerPublicKeyInfo adminGroupId:self.managerGuid adminGroup:managerPublicKeyInfo identityCertChain:identityCertificateChain manifestsXmls:[[NSArray alloc] initWithObjects: signedManifest, nil]];
    XCTAssertTrue(status == ER_OK, @"Failed to claim service application.");

    //Check claim status
    AJNApplicationState serviceApplicationStateAfterClaiming;
    [[self.bus permissionConfigurator] getApplicationState:&serviceApplicationStateAfterClaiming];
    XCTAssertTrue(serviceApplicationStateAfterClaiming == CLAIMED, @"Service wasn't been claimed.");

    AJNApplicationState clientApplicationStateAfterClaiming;
    [[client.bus permissionConfigurator] getApplicationState:&clientApplicationStateAfterClaiming];
    XCTAssertTrue(clientApplicationStateAfterClaiming == CLAIMED, @"Service wasn't been claimed.");

    //Install membership certificate
    status = [self installMembershipOnManager:managerProxyApplication alias:@"3" expirationTimeInSeconds:[[NSNumber alloc] initWithDouble:3600]];
    XCTAssertTrue(status == ER_OK, @"Failed to install membership to manager application.");

    status = [managerProxyApplication secureConnect:YES];
    XCTAssertTrue(status == ER_OK, @"Manager bus failed to secure connect.");

    status = [serviceProxyApplication secureConnect:YES];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to secure connect.");

    status = [clientProxyApplication secureConnect:YES];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to secure connect.");

    //end management
    status = [serviceProxyApplication endManagement];
    XCTAssertTrue(status == ER_OK, @"Failed to start management for service proxy application.");

    status = [clientProxyApplication endManagement];
    XCTAssertTrue(status == ER_OK, @"Failed to end management for client proxy application.");

    //update policy
    status = [serviceProxyApplication updatePolicyFromXml:kPolicy];
    XCTAssertTrue(status == ER_OK, @"Failed to update service proxy application policy.");
    status = [clientProxyApplication updatePolicyFromXml:kPolicy];
    XCTAssertTrue(status == ER_OK, @"Failed to update client proxy application policy.");

    status = [client.bus secureConnection:self.bus.uniqueName withForcedAuth:YES];
    XCTAssertTrue(status == ER_OK, @"Failed to security connect to service.");

    //Create proxy object on client bus
    SecureObjectProxy *secureProxyObject = [[SecureObjectProxy alloc] initWithBusAttachment:client.bus serviceName:[self.bus uniqueName] objectPath:kSecureObjectPath sessionId:0 enableSecurity:YES];

    status = [secureProxyObject introspectRemoteObject];
    XCTAssertTrue(status == ER_OK, @"Unable to introspect remote object.");

    NSString *concatenatedString = [secureProxyObject concatenateString:@"Foo " withString:@"bar"];
    NSString *expectedString = @"Foo bar";
    XCTAssertTrue([expectedString compare:concatenatedString] == NSOrderedSame, @"Unexpected concatenated strings. Value is [%@], have to be [%@]", concatenatedString, expectedString);

    //turn off all
    [self.managerBus clearKeyStore];
    status = [self.managerBus disconnect];
    XCTAssertTrue(status == ER_OK, @"Manager bus failed to disconnect.");
    status = [self.managerBus stop];
    XCTAssertTrue(status == ER_OK, @"Manager bus failed to stop.");

    [self.bus unregisterApplicationStateListener:self];
    [self.bus clearKeyStore];
    status = [self.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to disconnect.");
    status = [self.bus stop];
    XCTAssertTrue(status == ER_OK, @"Service bus failed to stop.");

    [client.bus unregisterApplicationStateListener:client];
    [client.bus clearKeyStore];
    status = [client.bus disconnect];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to disconnect.");
    status = [client.bus stop];
    XCTAssertTrue(status == ER_OK, @"Client bus failed to stop.");
}

#pragma AJNAuthenticationListener

- (AJNSecurityCredentials *)requestSecurityCredentialsWithAuthenticationMechanism:(NSString *)authenticationMechanism peerName:(NSString *)peerName authenticationCount:(uint16_t)authenticationCount userName:(NSString *)userName credentialTypeMask:(AJNSecurityCredentialType)mask
{
    NSLog(@"RequestCredentials for authenticating %@ using mechanism %@", peerName, authenticationMechanism);
    AJNSecurityCredentials *credentials = nil;
    if ([authenticationMechanism compare:@"ALLJOYN_ECDHE_NULL"] == NSOrderedSame) {
        if (authenticationCount <= 3) {
            // Need to send back something other the nil
            credentials = [[AJNSecurityCredentials alloc] init];
        }
    }
    else if ([authenticationMechanism compare:@"ALLJOYN_ECDHE_PSK"] == NSOrderedSame) {
        if (mask & kAJNSecurityCredentialTypePassword) {
            if (authenticationCount <= 3) {
                credentials = [[AJNSecurityCredentials alloc] init];
                if (!self.isWrongPasswordMustBeUsed) {
                    credentials.password = kCorrenctPassword;
                } else {
                    credentials.password = kInCorrenctPassword;
                }
            }
        }
    }
    else if ([authenticationMechanism compare:@"ALLJOYN_ECDHE_ECDSA"] == NSOrderedSame) {
        if (authenticationCount <= 3) {
            credentials = [[AJNSecurityCredentials alloc] init];
            if (mask & kAJNSecurityCredentialTypePrivateKey) {
                credentials.privateKey = self.isTestClient ? kClientEcdsaPrivateKeyPEM : kServerEcdsaPrivateKeyPEM;
            }
            if (mask & kAJNSecurityCredentialTypeCertificateChain) {
                credentials.certificateChain = self.isTestClient ? kClientEcdsaCertChainX509PEM : kServerEcdsaCertChainX509PEM;
            }
        }
    }
    return credentials;
}

- (void)authenticationUsing:(NSString *)authenticationMechanism forRemotePeer:(NSString *)peerName didCompleteWithStatus:(BOOL)success
{
    NSString *message = [NSString stringWithFormat:@"Authentication %@ %@.", authenticationMechanism, success ? @"successful" : @"failed"];
    NSLog(@"%@", message);
    if (success) {
        self.authenticationState = kAuthSuccess;
    } else {
        self.authenticationState = kAuthFailed;
    }
}

#pragma mark - AJNSessionPortListener implementation

- (BOOL)shouldAcceptSessionJoinerNamed:(NSString*)joiner onSessionPort:(AJNSessionPort)sessionPort withSessionOptions:(AJNSessionOptions*)options
{
    NSLog(@"AJNSessionPortListener::shouldAcceptSessionJoinerNamed:%@ onSessionPort:%u withSessionOptions:", joiner, sessionPort);
    if (sessionPort == kSessionDefaultPort) {
        return YES;
    }
    return NO;
}

- (void)didJoin:(NSString*)joiner inSessionWithId:(AJNSessionId)sessionId onSessionPort:(AJNSessionPort)sessionPort
{
    NSLog(@"AJNSessionPortListener::didJoin:%@ inSessionWithId:%u onSessionPort:%u withSessionOptions:", joiner, sessionId, sessionPort);
}

#pragma mark - AJNApplicationStateListener implementation

- (void)appStateChangedForRemoteBusAttachment:(NSString*)busName appPublicKeyInfo:(AJNKeyInfoNISTP256*)publicKeyInfo state:(AJNApplicationState)state
{
    NSLog(@"AJNApplicationStateListener::application state for %@ change to %i", busName, state);
    //TODO test this
}

@end
